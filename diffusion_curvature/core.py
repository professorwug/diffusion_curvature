# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/1 Core.ipynb.

# %% auto 0
__all__ = ['enforce_literals', 'DiffusionCurvature']

# %% ../nbs/1 Core.ipynb 8
from typing import Literal, get_args, get_origin
from inspect import getfullargspec
def enforce_literals(function):
    """Decorator that raises AssertionError on Literal check failure."""

    def decorator(*args, **kwargs):
        specs = getfullargspec(function)
        args = {key: args[i] for i, key in enumerate(specs.args) if i < len(args)}
        #  key_values = args | kwargs  # use this if python >= 3.9
        key_values = {**args_new, **kwargs}  # this is for python 3.8

        for name, type_ in getfullargspec(function).annotations.items():
            value = key_values[name]
            options = get_args(type_)
            if (
                get_origin(type_) is Literal
                and name in specs.args
                and value not in options
            ):
                raise AssertionError(f"'{value}' is not in {options} for '{name}'")
        return function(*args, **kwargs)

    return decorator


_TYPES = Literal["solar", "view", "both"]
_NUMS = Literal[1, 2, 3, 4, 5]

# %% ../nbs/1 Core.ipynb 9
import pygsp
import jax
import jax.numpy as jnp
from fastcore.all import *
import skdim

from .graphs import diff_aff, diff_op
from .heat_diffusion import heat_diffusion_on_signal, kronecker_delta, jax_power_matrix
from .diffusion_laziness import wasserstein_spread_of_diffusion, entropy_of_diffusion
from .distances import phate_distances
from .comparison_space import EuclideanComparison
import diffusion_curvature

_DIFFUSION_TYPES = Literal['diffusion matrix','heat kernel']
_LAZINESS_METHOD = Literal['Wasserstein','Entropic']
_COMPARISON_METHOD = Literal['Ollivier', 'Subtraction']

@enforce_literals
class DiffusionCurvature():
    def __init__(
            self,
            diffusion_type:_DIFFUSION_TYPES = 'diffusion matrix', # Either ['diffusion matrix','heat kernel']
            laziness_method: _LAZINESS_METHOD = 'Wasserstein', # Either ['Wasserstein','Entropic']
            comparison_method: _COMPARISON_METHOD = 'Ollivier',
            distance_method:function = phate_distances,
            dimest = None, # Dimension estimator to use. If none, defaults to kNN.
            different_comparison_space_for_each_point = False, # If true, constructs a comparison space for every point in the manifold. If false, only constructs unique comparison spaces for each unique dimension.
    ):
        store_attr()
        if self.dimest is None:
            self.dimest = skdim.id.KNN()
    def unsigned_curvature(
            self,
            G:pygsp.graphs.Graph, # PyGSP input Graph
            t:int, # Scale at which to compute curvature; number of steps of diffusion.
            idx=None, # the index at which to compute curvature. If None, computes for all points.
    ):
        n = G.L.shape[0]
        # Compute diffusion matrix
        match self.diffusion_type:
            case 'diffusion matrix':
                P = diff_op(G)
                P = jnp.array(P)
                Pt = jax_power_matrix(P,t) 
                if idx: Pt = Pt[idx] # TODO: Could be more efficient here
            case 'heat kernel':
                signal = jnp.eye(n) if idx else kronecker_delta(n,idx=idx)
                Pt = heat_diffusion_on_signal(G, signal, t)
            case _:
                raise ValueError(f"Diffusion Type {self.diffusion_type} not in {_DIFFUSION_TYPES}")
        match self.laziness_method:
            case "Wasserstein":
                D = self.distance_method(G) if not idx else self.distance_method(G)[idx] #TODO: Could be more efficient here
                laziness = wasserstein_spread_of_diffusion(D,Pt)
            case "Entropic":
                laziness = entropy_of_diffusion(Pt)
            case _:
                raise ValueError(f"Laziness Method {self.laziness_method} not in {_LAZINESS_METHOD}")
        return laziness
    def curvature(
            self,
            G:pygsp.graphs.Graph, # Input Graph
            t:int, # Scale
            idx=None, # the index at which to compute curvature. If None, computes for all points.
            dim = None, # the INTRINSIC dimension of your manifold, as an int for global dimension or list of pointwise dimensions; if none, tries to estimate pointwise.
    ):
        if dim is None: # The dimension wasn't supplied; we'll estimate it pointwise
            print("estimating local dimension of each point... may take a while")
            ldims = self.dimest.fit_pw(
                                G.data, #TODO: Currently this requires underlying points!
                                n_neighbors = 100,
                                n_jobs = 1)
            dims_per_point = np.round(ldims.dimension_pw_).astype(int)
        else: # the dimension *was* supplied, but it may be either a single global dimension or a local dimension for each point
            if isinstance(dim, int):
                dims_per_point = np.ones(G.P.shape[0], dtype=int)*dim
            else:
                dims_per_point = dim
        
        if self.different_comparison_space_for_each_point:
            pass
        else:
            unique_dims = set(dims_per_point)
            unique_flat_lazinesses = {}
            for d in unique_dims:
                G_flat = euclidean_comparison_space(G, dimension=d)
                G_flat = self.power_diffusion_matrix(G_flat,t)
                unique_flat_lazinesses = self.unsigned_curvature(G_flat, t, idx=0)
    


        
