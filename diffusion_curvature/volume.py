# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/Volume Estimation.ipynb.

# %% auto 0
__all__ = ['volume_via_heat_at_scales', 'calculate_radius_offset', 'actual_euclidean_volumes_at_radii']

# %% ../nbs/Volume Estimation.ipynb 7
import numpy as np
from .utils import kronecker_delta
from .heatkernel import expm_multiply, heat_diffusion_on_signal
def volume_via_heat_at_scales(
    G, # a pygsp graph 
    idx, # index of point to grow ball from. If none, returns sequence of volumes for every idx.
    ts, # list of times (or single time). 
    denoising_scale = 5, # if nonzero, denoises the heat estimate by replacing with the expected value of heat measured against a diffusion with t=denoising_scale
):
    """
    Returns a list of volumes of the t-step balls constructed at point i, for each t in ts.
    If idx=None, returns a matrix where each row is as above.
    """
    n = G.L.shape[0]
    x = kronecker_delta(n,idx)
    if denoising_scale > 0: # replace h_t(i,i) with its expected value, measured against the first diffusion
        ts_with_denoising = np.concatenate([[denoising_scale],np.array(ts)])
        diffused_at_scales = heat_diffusion_on_signal(G,np.eye(n), ts_with_denoising) # each signal is a row
        diffused_at_scales = np.array(diffused_at_scales) # a 3d array of shape num ts x n x n
        if idx is None:
            denoising_distribution = diffused_at_scales[0].T
        else:
            denoising_distribution = diffused_at_scales[0][idx].T
        # get diagonals of each second dimension
        diagonals_of_diffusion = np.array([np.diag(D) for D in diffused_at_scales[1:]])
        # take expected value according to ith idx # TODO: For multi-point diffusion, just repeat this for several idx
        diffused_denoised = diagonals_of_diffusion @ denoising_distribution
        diffused_denoised = diffused_denoised.T
        volumes = 1 / diffused_denoised
        # print("using denoising",denoising_scale)
    else:
        diffused_at_scales = heat_diffusion_on_signal(G,x, ts) # each signal is a row
        diffused_at_scales = np.array(diffused_at_scales)
        volumes = 1/diffused_at_scales[:,idx] # the ith column has the self affinities
    return volumes

# %% ../nbs/Volume Estimation.ipynb 12
from sympy import Symbol, pi, solve
from scipy.special import gamma
import numpy as np

def calculate_radius_offset(n):
    r = Symbol('r')  # radius of the n-sphere
    V = (pi**(n/2) / (gamma(n/2 + 1))) * r**n  # formula for the volume of an n-sphere
    # Solve for radius r when V = 1
    radius_solution = solve(V - 1, r)
    if radius_solution:
        return np.abs(radius_solution[0].evalf())  # return the numerical value of the radius
    else:
        return None  # no solution found

# %% ../nbs/Volume Estimation.ipynb 18
from scipy.special import gamma
def actual_euclidean_volumes_at_radii(
        dim,
        radii
):
    vols = []
    for r in radii:
        v = np.pi**(dim/2)/(gamma(dim/2+1))*r**dim
        vols.append(v)
    return np.array(vols)
