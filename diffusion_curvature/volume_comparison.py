# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/Curvature by Quadratic Fitting.ipynb.

# %% auto 0
__all__ = ['volume_comparisons_of_graph_at_idx', 'extract_scalar_curvature', 'extract_scalar_curvature_with_offset_compensation',
           'scalar_curvatures_of_graph']

# %% ../nbs/Curvature by Quadratic Fitting.ipynb 5
import numpy as np
from .graphs import get_alpha_decay_graph
from .datasets import plane
from .volume import volume_via_heat_at_scales, actual_euclidean_volumes_at_radii
def volume_comparisons_of_graph_at_idx(
        G, # pygsp graph
        idx, # node idx to get comparisons from. If None, returns comparisons across all indxs
        dim, # intrinsic dimension of graph/manifold
        ts, # diffusion times at which to give comparison
        use_sampled_euclidean = True,
        verbose=True,
        knn = 15,
        anisotropy = 0.5,
        decay = 20,
        denoising_scale = 5
):
    """Returns the ratio of Vol(B_m)/Vol(B_E) at each of the times"""
    vols_manifold = volume_via_heat_at_scales(G,idx,ts, denoising_scale=denoising_scale)
    radii = np.sqrt(ts)
    if use_sampled_euclidean:
        # TODO: can be expanded to incorporate sampling
        num_points_per_dim = G.L.shape[0]
        X_euc = plane(n=num_points_per_dim, dim=dim)
        G_euc = get_alpha_decay_graph(X_euc,knn=knn,decay=decay,anisotropy=anisotropy) 
        # G_euc = get_alpha_decay_graph(X_euc,knn=G.knn,decay=G.decay,anisotropy=G.anisotropy) 
        vols_euclidean = volume_via_heat_at_scales(G_euc,idx=0,ts=ts,denoising_scale=denoising_scale)
        # if verbose: print(f"G has knn {G.knn}, anisotropy {G.anisotropy}, and decay {G.decay}") # Due to a bug in graphtools, these values aren't accurate.
    else:
        vols_euclidean = actual_euclidean_volumes_at_radii(dim, radii)
    if len(vols_manifold.shape) == 3: # we've computed volumes at all indxs
        ratios = []
        for VM in vols_manifold:
            ratios.append(VM/vols_euclidean)
        return np.array(ratios)
    else:
        return vols_manifold/vols_euclidean

# %% ../nbs/Curvature by Quadratic Fitting.ipynb 6
def extract_scalar_curvature(
        radii, 
        volume_ratios,
        dim,
        verbose=False
        ):
    coeffs = np.polyfit(radii, volume_ratios, deg=3) # highest power returned first
    if verbose: print(f"Coeffs are {coeffs}")
    S = -coeffs[1]*6*(dim+2)
    return S

# %% ../nbs/Curvature by Quadratic Fitting.ipynb 8
from .volume import calculate_radius_offset
def extract_scalar_curvature_with_offset_compensation(
        ts,
        volume_ratios,
        dim,
        verbose=False,
):
    ts_adjusted = np.sqrt(ts)
    # since the polynomial is in sqrt(t)
    coeffs = np.polyfit(ts_adjusted, volume_ratios, deg=2) 
    # highest power returned first 
    if verbose:print(f"returned coeffs are")
    offset = calculate_radius_offset(dim)
    S_prime = (-coeffs[1]**2)/(4*coeffs[0]*offset)
    S = S_prime*6*(dim+2)
    return S


# %% ../nbs/Curvature by Quadratic Fitting.ipynb 41
from tqdm.notebook import trange
def scalar_curvatures_of_graph(
    G, 
    dim,
    ts = np.arange(1,10),
    knn=15,
    decay=20, 
    anisotropy=0.5
):
    ks = np.empty(G.L.shape[0])
    ratios_all_i = volume_comparisons_of_graph_at_idx(
            G,
            None, # compute for all idx
            dim,
            ts,
            knn=knn,decay=decay, anisotropy=anisotropy
        )
    for i in trange(len(ks)):
        ratios = ratios_all_i[i]
        ks[i] = extract_scalar_curvature_with_offset_compensation(np.sqrt(ts),ratios,dim)
    return ks
